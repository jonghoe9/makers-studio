{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Makers Studio Docs","text":"<p>\uc544\uc774\ub514\ub098\uc778\uc758 \uacf5\uc791 \ud504\ub85c\uc81d\ud2b8 \uae30\ub85d\ub4e4</p> <ul> <li>Parts : \ubd80\ud488\ub4e4\uc744 \uc0ac\uc6a9\ud558\uae30 \uc704\ud55c \uae30\ubcf8 \uc124\uc815 \ubaa8\uc74c</li> <li>Concepts : \uac01\uc885 \ubd80\ud488\ub4e4\uc744 \uc0ac\uc6a9\ud558\uae30 \uc704\ud55c \uae30\ubcf8 \ucf54\ub4dc \ubaa8\uc74c</li> <li>Projects : \uc5ec\ub7ec \ubd80\ud488\uacfc \ucee8\uc149\ub4e4\uc744 \ubaa8\uc544 \uacb0\uacfc\ubb3c\uc744 \ub9cc\ub4e0\ub2e4.</li> </ul>"},{"location":"#projects","title":"Projects","text":"<ul> <li>The Weight, 2025</li> </ul>"},{"location":"#parts","title":"Parts","text":"<ul> <li>AC Servo Motor</li> <li>DC Servo Motor (RC)</li> <li>Stepping Motor</li> <li>Geared Stepping Motor</li> <li>\ucd08\uc74c\ud30c \uc13c\uc11c</li> </ul>"},{"location":"#concepts","title":"Concepts","text":"<ul> <li>\uc0ac\ub78c \uc778\uc2dd - 2.4G Presence Sensor</li> <li>RC Receiver Read</li> <li>DMX Read</li> <li>Artnet Read</li> </ul>"},{"location":"01_Concepts/ESP32_Wifi/01_esp32_wifi_connect/","title":"ESP32 Wifi Connect","text":"esp32_wifi_webserver.inl<pre><code>#include &lt;WiFi.h&gt;\n\n#define LED_PIN 2\n\nconst char* ssid     = \"ss_id\";\nconst char* password = \"********\";\n\n//WiFiServer server(80);\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(500);\n  pinMode(LED_PIN, OUTPUT);\n\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    digitalWrite(LED_PIN, LOW);\n    delay(250);\n    Serial.print(\".\");\n    digitalWrite(LED_PIN, HIGH);\n    delay(250);\n  }\n  digitalWrite(LED_PIN, HIGH);\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected.\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop() {\n  Serial.println(WiFi.localIP());\n  delay(300);\n}\n</code></pre>"},{"location":"01_Concepts/ESP32_Wifi/02_esp32_wifi_webserver/","title":"ESP32 Wifi WebServer Setup","text":"esp32_wifi_webserver.inl<pre><code>#include &lt;WiFi.h&gt;\n\nconst char *ssid = \"Donggu_Free-WiFi\";\nconst char *password = \"\";\n\nNetworkServer server(80);\n\nvoid setup() {\n  Serial.begin(115200);\n  wifi_connect();\n}\n\nvoid loop() {\n  NetworkClient client = server.accept();\n  if(client) {\n    Serial.println(\"New Client.\");  // print a message out the serial port\n    String currentLine = \"\";        // make a String to hold incoming data from the client\n    while (client.connected()) {    // loop while the client's connected\n      if (client.available()) {     // if there's bytes to read from the client,\n        char c = client.read();     // read a byte, then\n        Serial.write(c);            // print it out the serial monitor\n        if (c == '\\n') {            // if the byte is a newline character\n          if (currentLine.length() == 0) {\n            client.println(\"HTTP/1.1 200 OK\");\n            client.println(\"Content-type:text/html\");\n            client.println();\n            client.print(\"Click &lt;a href=\\\"/H\\\"&gt;[ON]&lt;/a&gt; LED ON (Serial Off)&lt;br&gt;\");\n            client.print(\"Click &lt;a href=\\\"/L\\\"&gt;[OFF]&lt;/a&gt; Scene Mode OFF (Serial On)&lt;br&gt;\");\n            client.println();\n            break;\n          } else {\n            currentLine = \"\";\n          }\n        } else if (c != '\\r') {\n          currentLine += c;\n        }\n        if (currentLine.endsWith(\"GET /H\")) {\n          digitalWrite(2, HIGH);  // GET /H turns the LED on\n        }\n        if (currentLine.endsWith(\"GET /L\")) {\n          digitalWrite(2, LOW);  // GET /L turns the LED off\n        }\n      }\n    }\n    // close the connection:\n    client.stop();\n    Serial.println(\"Client Disconnected.\");\n  }\n}\n\nvoid wifi_connect() {\n  Serial.println();\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected.\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  server.begin();\n}\n</code></pre>"},{"location":"01_Concepts/ESP32_Wifi/03_esp32_w_udp_client/","title":"ESP32 Wifi UDP Client","text":"<ul> <li>ESP32\uc5d0\uc11c Wifi \uc811\uc18d \ud6c4 \ub370\uc774\ud130 Send</li> <li>\uc1a1\uc2e0 \ub370\uc774\ud130 \ud655\uc778\uc740 tcpdump \uba85\ub839\uc5b4\ub85c \ud655\uc778 \uac00\ub2a5\ud558\ub2e4</li> </ul> <pre><code>sudo tcpdump -i en0 -X -v 'udp port 8765'\n</code></pre> <ul> <li>\ud2b9\uc815 IP\uc640 Port\uc5d0 \ubb38\uc790\uc5f4 \uc804\uc1a1\ud558\uae30 </li> </ul> <pre><code>$ nc -u 192.168.1.111 8765\nHello\n$\n</code></pre> esp32_wifi_udp_client1.ino<pre><code>#include &lt;WiFi.h&gt;\n\nconst char* ssid = \"ssid\";\nconst char* password = \"*******\";\n\nconst char* dest_ip = \"192.168.6.255\";\nunsigned int dest_port = 50000;\n\nWiFiUDP udp;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(500);\n  Serial.printf(\"Connecting to %s \", ssid);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\" CONNECTED\");\n}\n\nvoid loop() {\n  udp.beginPacket(dest_ip, dest_port);\n  udp.printf(\"Packet received OK by ESP32 server\\n\");\n  udp.endPacket();\n  delay(1000);\n}\n</code></pre> esp32_wifi_udp_client2.ino<pre><code>#include &lt;WiFi.h&gt;\n\nconst char* ssid     = \"ssid\";\nconst char* password = \"********\";\n\nconst char* udp_dest = \"192.168.6.255\";\nconst int udp_port = 50000;\n\nboolean chk_wifi = false;\n\nWiFiUDP udp;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"\\n\\nConnecting to \" + String(ssid));\n  delay(200);\n  WiFi.disconnect(true);\n  WiFi.onEvent(WiFiEvent);\n  WiFi.begin(ssid, password);\n}\n\nvoid loop() {\n  char* msg = \"Seconds since boot\";\n  udp_send(msg);\n  delay(1000);\n}\n\nvoid WiFiEvent(WiFiEvent_t event) {\n  switch(event) {\n    case ARDUINO_EVENT_WIFI_STA_GOT_IP:\n      Serial.print(\"MyIP: \");\n      Serial.println(WiFi.localIP());\n      chk_wifi = true;\n      break;\n    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:\n      Serial.println(\"Wifi lost connection.\");\n      chk_wifi = false;\n      break;\n    default:\n      break;\n  }\n}\n\nvoid udp_send(char* message) {\n  if(chk_wifi) {\n    udp.beginPacket(udp_dest, udp_port);\n    udp.printf(\"%s : %lu\", message, millis()/1000);\n    udp.endPacket();\n  }\n}\n</code></pre>"},{"location":"01_Concepts/ESP32_Wifi/04_esp32_w_udp_server/","title":"ESP32 Wifi UDP Server","text":"esp32_wifi_udp_server.ino<pre><code>#include &lt;WiFi.h&gt;\n//#include &lt;WiFiUdp.h&gt;\n\n#define BUFF_SIZE 255\n\nconst char* ssid = \"df_stage24\";\nconst char* password = \"dfdf8993\";\nunsigned int port_listen = 50000;\n\nchar packetBuffer[BUFF_SIZE];\n\nWiFiUDP udp;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(500);\n  Serial.printf(\"Connecting to %s \", ssid);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\" CONNECTED\");\n\n  udp.begin(port_listen);\n  Serial.printf(\"UDP server started at %s:%i\\n\",\n                WiFi.localIP().toString().c_str(),\n                port_listen);\n}\n\nvoid loop() {\n  int packetSize = udp.parsePacket();\n  if (packetSize) {\n    Serial.printf(\"Received packet of size %i from %s:%i\\n\",\n                    packetSize,\n                    udp.remoteIP().toString().c_str(), \n                    udp.remotePort());\n\n    int len = udp.read(packetBuffer, BUFF_SIZE);\n    if (len &gt; 0) {\n      packetBuffer[len] = 0;\n    }\n    Serial.printf(\"Data: %s\\n\", packetBuffer);\n\n    udp.beginPacket(udp.remoteIP(), udp.remotePort());\n    udp.printf(\"Packet received OK by ESP32 server\\n\");\n    udp.endPacket();\n  }\n}\n</code></pre>"},{"location":"01_Concepts/ESP32_Wifi/05_esp32_w_udp_device/","title":"ESP32 WIFI UDP Device","text":"<ul> <li>\uc7a5\uce58\uc5d0\uc11c Wifi \uc811\uc18d, DHCP\ub85c IP \ubc1b\uc74c (broad_port:30000)</li> <li>\ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8 \uc8fc\uc18c\ub85c \uc7a5\uce58 \uc815\ubcf4 \ubcf4\ub0b4\uae30 (1\ucd08 \ub9c8\ub2e4 \ubcf4\ub0c4)</li> <li>\uc7a5\uce58\ub294 \ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8\ub85c \ubc1c\uc2e0\uc790 \uc815\ubcf4\ub97c \ubc1b\uc544, \uc7a5\uce58\uc758 IP\ub97c \ub2f5\uc2e0\ud568</li> <li>\uc11c\ubc84\ub294 \uc7a5\uce58 \uc815\ubcf4\ub97c \ubc1b\uc544 \uc7a5\uce58\ub97c \ub4f1\ub85d\ud568</li> </ul> esp32_wifi_udp_device.ino<pre><code>#include &lt;WiFi.h&gt;\n\n// ============================================ Setup Start\n// WIFI \uc815\ubcf4 \uc785\ub825\nconst char* ssid = \"ssid\";\nconst char* password = \"********\";\n\n// \uc7a5\uce58 \uc815\ubcf4\uc640 \ud3ec\ud2b8 \uc124\uc815\nconst unsigned int device_id = 9;\nconst unsigned int listen_port = 29998;\nconst unsigned int dest_port = 29999;\nconst unsigned int broad_port = 30000;\nconst String device_name = \"ESP32 Wifi bt9 Style Device #1\";\n// ============================================ Setup End\n\nWiFiUDP udp;\nString device_ip = \"\";\nString broad_ip = \"\";\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(500);\n  Serial.printf(\"\\n\\nConnecting to Wifi %s \", ssid);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\" CONNECTED\");\n\n  device_ip = WiFi.localIP().toString();\n  broad_ip = device_ip.substring(0, device_ip.lastIndexOf('.'));\n  broad_ip += \".255\";\n\n  Serial.print(\"Device ID: \");\n  Serial.println(device_id);\n  Serial.print(\"Device: \");\n  Serial.println(device_name);\n  Serial.print(\"Device IP: \");\n  Serial.println(device_ip);\n  Serial.print(\"Device Listen Port: \");\n  Serial.println(listen_port);\n  Serial.print(\"Broadcast IP: \");\n  Serial.println(broad_ip);\n  Serial.print(\"Broadcast Port: \");\n  Serial.println(broad_port);\n  Serial.print(\"Destination IP: \");\n  Serial.println();\n  Serial.print(\"Destination Port: \");\n  Serial.println(dest_port);\n\n\n  //udp.begin(port_listen);\n  //Serial.printf(\"UDP server started at %s:%i\\n\",\n  //              WiFi.localIP().toString().c_str(),\n  //              port_listen);\n}\n\nvoid loop() {\n  /*\n  int packetSize = udp.parsePacket();\n  if (packetSize) {\n    Serial.printf(\"Received packet of size %i from %s:%i\\n\",\n                    packetSize,\n                    udp.remoteIP().toString().c_str(), \n                    udp.remotePort());\n\n    int len = udp.read(packetBuffer, BUFF_SIZE);\n    if (len &gt; 0) {\n      packetBuffer[len] = 0;\n    }\n    Serial.printf(\"Data: %s\\n\", packetBuffer);\n\n\n    */\n  // Broadcast Send, Device Info\n  udp.beginPacket(broad_ip.c_str(), broad_port);\n  udp.printf(\"%d, %s, %s, %d\\n\",\n            device_id, device_name, device_ip, listen_port);\n  udp.endPacket();\n  delay(1000);\n}\n</code></pre>"},{"location":"01_Concepts/XCode_UDP/01_udp_server_cli/","title":"XCode CLI | UDP Server","text":"<pre><code>//\n//  main.swift\n//  swift_udp_server_cli\n//\n\nimport Foundation\nimport Network\n\nlet port: NWEndpoint.Port = 50000\nlet parameters = NWParameters.udp\n//parameters.requiredInterfaceType = .wifi\nparameters.allowLocalEndpointReuse = true\n\ndo {\n    let listener = try NWListener(using: parameters, on: port)\n    listener.newConnectionHandler = { connection in\n        connection.start(queue: .global())\n        func receiveNextMessage() {\n            connection.receiveMessage { (data, context, isComplete, error) in\n                if let data = data,\n                   let message = String(data: data, encoding: .utf8) {\n                    if let localEndpoint = connection.currentPath?.localEndpoint {\n                        print(\"Listen: \\(localEndpoint)\")\n                    }\n                    print(\"From: \\(connection.endpoint)\")\n                    print(\"Message: \\(message)\")\n                    print(\"--------------------------------\")\n                }\n                if error == nil {\n                    receiveNextMessage()\n                } else {\n                    connection.cancel()\n                }\n            }\n        }\n        receiveNextMessage()\n    }\n\n    listener.stateUpdateHandler = { state in\n        switch state {\n        case .ready:\n            print(\"UDP Server ready on \\(port)\")\n        case .failed(let error):\n            print(\"Server Error: \\(error)\")\n            exit(EXIT_FAILURE)\n        default:\n            break\n        }\n    }\n    listener.start(queue: .main)\n} catch {\n    print(\"Server Strart Failed: \\(error)\")\n    exit(1)\n}\n\nRunLoop.main.run()\n</code></pre>"},{"location":"01_Concepts/XCode_UDP/02_udp_client_cli/","title":"XCode CLI | UDP Client (Broadcast)","text":"<pre><code>//\n//  main.swift\n//  wift_udp_client_broadcast_cli\n//\n// 1\ucd08\uc5d0 \ud55c\ubc88\uc529 \ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8\ub85c \uba54\uc138\uc9c0 \uc804\uc1a1\ud558\ub294 \ud504\ub85c\uadf8\ub7a8\n//\n\nimport Foundation\nimport Network\n\nclass UDPBroadcastClient {\n    private var connection: NWConnection?\n    private var timer: Timer?\n    private let queue = DispatchQueue(label: \"UDPBroadcastQueue\")\n\n    // \ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8 \uc8fc\uc18c\uc640 \ud3ec\ud2b8 \uc124\uc815\n    private let broadcastAddress = NWEndpoint.Host(\"255.255.255.255\")\n    private let port = NWEndpoint.Port(rawValue: 8888)!\n\n    func startBroadcasting() {\n        let parameters = NWParameters.udp\n        if let ipv4Options = parameters.defaultProtocolStack.internetProtocol as? NWProtocolIP.Options {\n            ipv4Options.version = .v4\n        }\n        connection = NWConnection(host: broadcastAddress, port: port, using: parameters)\n        connection?.stateUpdateHandler = { state in\n            switch state {\n            case .ready:\n                print(\"\ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8 \uc900\ube44 \uc644\ub8cc\")\n                self.setupTimer()\n            case .failed(let error):\n                print(\"\uc5f0\uacb0 \uc2e4\ud328: \\(error)\")\n            default:\n                break\n            }\n        }\n        connection?.start(queue: queue)\n    }\n\n    private func setupTimer() {\n        DispatchQueue.main.async {\n            self.timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n                self?.sendPing()\n            }\n        }\n    }\n\n    private func sendPing() {\n        let message = \"idNINE Device Center Ping at \\(Date().description)\"\n        let data = message.data(using: .utf8)\n\n        connection?.send(content: data, completion: .contentProcessed({ error in\n            if let error = error {\n                print(\"\uc804\uc1a1 \uc5d0\ub7ec: \\(error)\")\n            } else {\n                print(\"\uba54\uc2dc\uc9c0 \ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8 \uc131\uacf5: \\(message)\")\n            }\n        }))\n    }\n\n    func stop() {\n        timer?.invalidate()\n        connection?.cancel()\n        print(\"\ube0c\ub85c\ub4dc\uce90\uc2a4\ud2b8 \uc911\ub2e8\")\n    }\n}\n\nlet client = UDPBroadcastClient()\nclient.startBroadcasting()\n\nRunLoop.main.run()\n</code></pre>"},{"location":"01_Concepts/XCode_UDP/03_udp_device_ctrl_cli/","title":"XCode CLI | Device Center","text":"<pre><code>//\n//  main.swift\n//  swift_udp_ctrl_center\n//\n\nimport Foundation\nimport Network\n\n// MARK: - [UDP Server, Listen]\nfunc startUDPServer(port: NWEndpoint.Port) {\n    let listener = try! NWListener(using: .udp, on: port)\n    listener.newConnectionHandler = { conn in\n        conn.start(queue: .global())\n        func receive() {\n            conn.receiveMessage { data, _, _, _ in\n                if let data = data, let msg = String(data: data, encoding: .utf8) {\n                    print(\"Received: \\(msg)\")\n                }\n                receive()\n            }\n        }\n        receive()\n    }\n    listener.start(queue: .main)\n    print(\"UDP Server started on port \\(port)\")\n}\n\n// MARK: - [UDP Client, Brocast Send]\nclass UDPBroadcastClient {\n    private var connection: NWConnection?\n    private let timer = DispatchSource.makeTimerSource(queue: .main)\n    private let targetPort: NWEndpoint.Port\n\n    private let dateFormatter: DateFormatter = {\n        let df = DateFormatter()\n        df.dateFormat = \"yyyy.MM.dd HH:mm:ss 'KST'\"\n        df.timeZone = TimeZone(secondsFromGMT: 9 * 3600)\n        return df\n    }()\n\n    init(port: UInt16) {\n        self.targetPort = NWEndpoint.Port(rawValue: port)!\n    }\n\n    func start() {\n        connection = NWConnection(host: \"255.255.255.255\", port: targetPort, using: .udp)\n        connection?.start(queue: .main)\n\n        timer.schedule(deadline: .now(), repeating: 1.0)\n        timer.setEventHandler { [weak self] in\n            guard let self = self else { return }\n            let dateString = self.dateFormatter.string(from: Date())\n            let message = \"id9dc:, idNINE Device Center Ping at \\(dateString)\"\n\n            self.connection?.send(content: message.data(using: .utf8), completion: .contentProcessed { error in\n                if let error = error { print(\"Send Error: \\(error)\") }\n            })\n        }\n        timer.resume()\n        print(\"Broadcasting to port \\(targetPort) ...\")\n    }\n}\n\n// MARK: - [\uc2e4\ud589\ubd80]\nstartUDPServer(port: 50000)\n\nlet client = UDPBroadcastClient(port: 54321)\nclient.start()\n\nRunLoop.main.run()\n</code></pre>"},{"location":"02_Parts/","title":"Parts","text":""},{"location":"02_Parts/#boards","title":"Boards","text":"<ul> <li>ESP Wroom 32 : ESP Wroom 32 \ubc84\uc804 \uc14b\uc5c5, \uc544\ub450\uc774\ub178 \uc5f0\uacb0 \ubc29\ubc95</li> <li>Raspberry-Pi PICO</li> </ul>"},{"location":"02_Parts/_ESP_Wroom_32/","title":"ESP Wroom 32","text":""},{"location":"02_Parts/_ESP_Wroom_32/#pinout","title":"Pinout","text":"<p>ESP Wroom 32 Board</p> <p></p> <ul> <li>\ub0b4\uc7a5 LED\ub294 GPIO-2</li> </ul>"},{"location":"02_Parts/_ESP_Wroom_32/#arduino-setup","title":"Arduino Setup","text":""},{"location":"02_Parts/_ESP_Wroom_32/#test-code-blink","title":"Test Code (Blink)","text":"esp32-blink.ino<pre><code>#define LED_PIN 2\nvoid setup() {\n    pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(LED_PIN, HIGH);\n    delay(300);\n    digitalWrite(LED_PIN, LOW);\n    delay(300);\n}\n</code></pre>"},{"location":"09_MkDocs/","title":"MkDocs","text":"<pre><code>mkdocs build\nmkdocs serve\n</code></pre>"},{"location":"09_MkDocs/#tips","title":"Tips","text":"<ul> <li>mkdocs serve \ub294 \uae30\ubcf8\uc801\uc73c\ub85c \ub77c\uc774\ube0c ReLoad\uac00 \ub418\uc9c0\ub9cc, \ud544\uc694\ud558\ub2e4\uba74 \uba85\uc2dc\ud560 \uc218 \uc788\ub2e4.</li> </ul> <pre><code>mkdocs serve --livereload\n</code></pre>"}]}